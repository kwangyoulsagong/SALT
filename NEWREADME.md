<div align="center">

<h1>SALT</h1>
<img src="https://github.com/kwangyoulsagong/SALT/blob/feat2/adding-goals/readmeAsset/main.png">
<h3> "금융과 재미를 결합한 새로운 방식의 자산 관리 플랫폼" </h3>
<br />

<h2>재미있고 지속 가능한 저축 습관을 위한 공간</h2>

저축 목표를 설정하고, 게임화된 요소와 소셜 기능을 활용하여  
즐겁게 금융 습관을 만들어보세요.

최적화된 저축 관리 시스템으로 목표 달성을 더 쉽게!

다양한 목표 설정 방식 지원
리워드 기반의 동기 부여 시스템
친구들과 함께하는 소셜 저축 기능

직관적인 인터페이스로 저축 경험을 새롭게 정의하세요.

</br>

</div>

<br />

# 목차

### [1. 프로젝트 소개](#%EF%B8%8F-프로젝트-소개)

- [< SALT >를 만들게 된 계기](#-SALT-를-만들게-된-계기)
- [주요 기능 설명](#주요-기능-설명)
- [프로젝트 실행 방법](#프로젝트-실행-방법)

### [2. 기술 스택](#%EF%B8%8F-기술-스택)

### [3. 기술적 경험](#-기술적-경험)

- [FE](#FE)
  - [성능 최적화](#성능-최적화)

<br />

# ⭐️ 프로젝트 소개

## < SALT >를 만들게 된 계기

많은 사람들이 저축을 계획하지만, 꾸준히 유지하는 것은 쉽지 않습니다.  
목표 없이 저축을 하면 동기부여가 어렵고, 단순히 숫자로만 표시되는 저축 금액은 지루하게 느껴질 수 있습니다.

우리는 저축을 보다 직관적이고 재미있는 경험으로 만들고 싶었습니다.  
목표를 설정하고, 게임처럼 즐기면서 저축할 수 있다면 더 지속 가능하지 않을까?  
이런 고민에서 **SALT**가 탄생했습니다.

#### 기존 저축 방식의 한계

금융 앱을 사용해 본 경험이 있다면 이런 불편함을 느껴봤을 겁니다:

- **목표 설정이 어렵다**: 단순히 금액만 입력하는 방식은 동기부여가 부족합니다.
- **저축이 지루하다**: 숫자만 쌓이는 구조라 흥미를 잃기 쉽습니다.
- **꾸준히 유지하기 힘들다**: 실시간 피드백과 보상이 부족해 동기부여가 약합니다.
- **소셜 기능이 없다**: 함께하는 재미가 없으면 쉽게 포기하게 됩니다.

#### 그래서 우리는 새로운 방식의 저축 서비스를 만들기로 했습니다.

저축을 단순한 ‘금융 관리’가 아니라 **게임처럼 즐길 수 있는 경험**으로 바꾸고 싶었습니다.  
목표를 설정하고, 도전하며, 보상을 받으며 성장하는 재미있는 서비스,  
그것이 바로 **SALT**입니다.

<br />

## 주요 기능 설명

( gif 로딩이 느릴 수 있습니다🥹 조금만 기다려주세요 )

### [ 메인 페이지 ]

  <img src="https://github.com/kwangyoulsagong/SALT/blob/feat2/adding-goals/readmeAsset/mainView.gif" alt="메인 뷰">

#### 1. **저축 현황 한눈에 보기**

- 현재 저축 진행 상황과 목표 달성률을 직관적으로 확인할 수 있습니다.
- 목표별 저축 진행도를 그래프와 함께 제공하여 동기부여를 극대화합니다.

#### 2. **오늘의 미션**

- "오늘 커피 한 잔 대신 5천 원 저축하기"와 같은 데일리 미션 제공.
- 미션을 성공하면 보상을 획득하고, 꾸준한 저축 습관을 형성할 수 있습니다.

#### 3. **지출 분석**

- 이번 달 지출 내역과 저축 비율을 분석하여 효율적인 금전 관리 지원.
- 카테고리별 지출 그래프를 제공하여 절약 포인트를 쉽게 파악할 수 있습니다.

#### 4. **이달의 저축왕**

- 가장 꾸준히 저축한 사용자 랭킹을 공개하여 참여자들의 동기부여 강화.
- 친구들과 함께 경쟁하며 재미있게 저축 습관을 만들어 갈 수 있습니다.

#### 5. **오늘의 금융 팁**

- "소액 투자로 시작하는 저축 방법" 같은 실용적인 금융 정보를 매일 제공.
- 저축과 재테크에 대한 다양한 팁을 받아볼 수 있습니다.

#### 6. **게임**

- 저축을 재미있게 즐길 수 있도록 다양한 게임 요소 추가.
- 저축 테트리스, 목표 달성 모험 게임 등으로 금전 관리를 놀이처럼 경험하세요.

### [ 저축 추가 및 뱅킹 ]

<table>
  <tr>
    <td><img src="https://github.com/kwangyoulsagong/SALT/blob/feat2/adding-goals/readmeAsset/bank.gif" alt="블록 에디터 1" /></td>
    <td><img src="https://github.com/kwangyoulsagong/SALT/blob/feat2/adding-goals/readmeAsset/%EA%B3%84%EC%A2%8C%EC%84%A0%ED%83%9D.png" alt="블록 에디터 2" /></td>
  </tr>
</table>

#### **1. 저축 추가 기능**

- 원하는 **저축 목표 태그**를 선택하고, 목표 금액과 기간을 입력하여 손쉽게 저축을 시작할 수 있습니다.
- 직관적인 UI로 누구나 빠르게 저축 목표를 설정할 수 있습니다.

#### **2. 계좌 선택 및 연동**

- 다양한 은행 서비스와 연동하여 사용자가 직접 계좌를 선택하고 저축을 진행할 수 있습니다.
- **원하는 계좌를 선택**한 후, 자동 저축 기능을 활용하여 더욱 편리하게 목표를 달성할 수 있습니다.

## 프로젝트 실행 방법

```bash
pnpm install

pnpm dev
```

<br />

# ⚒️ 기술 스택

<img src="https://github.com/kwangyoulsagong/Reflective/blob/main/readmeAssets/skills.png" height="500" alt="기술스택 이미지"/>

```
graph TD
    Shell["Shell 앱 (컨테이너)"]

    %% 마이크로프론트엔드 앱들
    Analysis["Analysis 마이크로앱"]
    Bank["Bank 마이크로앱"]
    Game["Game 마이크로앱"]
    Goals["Goals 마이크로앱"]
    Missions["Missions 마이크로앱"]
    Notification["Notification 마이크로앱"]
    Ranking["Ranking 마이크로앱"]
    Social["Social 마이크로앱"]

    %% 공통 서비스
    AuthService["인증 서비스"]
    MessageBus["이벤트 버스"]

    %% 연결
    Shell --> Analysis
    Shell --> Bank
    Shell --> Game
    Shell --> Goals
    Shell --> Missions
    Shell --> Notification
    Shell --> Ranking
    Shell --> Social

    %% 공통 서비스 연결
    AuthService --> Shell
    MessageBus --> Shell

    %% 스타일링
    classDef container fill:#1a2233,stroke:#4080ff,color:#4c8cff,stroke-width:2px;
    classDef micro fill:#243042,stroke:#4c8cff,color:#4c8cff;
    classDef service fill:#1f2935,stroke:#50a14f,color:#50a14f;

    class Shell container;
    class Analysis,Bank,Game,Goals,Missions,Notification,Ranking,Social micro;
    class AuthService,MessageBus service;
```

# 💪🏻 기술적 경험

## FE

프론트엔드의 주요 기술적 도전은 독립적인 서비스로 마이크로 프론트엔드 아키텍처를 구축하는게 목표였습니다.

### 왜 마이크로프론트엔드에 매료되었나?

개인 프로젝트로 SALT를 개발하면서, 새로운 아키텍처를 공부하고 적용해보고 싶다는 욕구가 있었습니다. 마이크로프론트엔드는 프론트엔드 영역에서 비교적 새롭게 떠오르는 아키텍처로, 실무에서 쉽게 접하기 어려운 기술이기에 더욱 흥미로웠습니다.

물론 개인 프로젝트에 마이크로프론트엔드를 적용하는 것이 오버엔지니어링처럼 보일 수 있습니다. 하지만 요즘 많은 기업들이 점진적으로 모놀리식 애플리케이션에서 마이크로프론트엔드로 마이그레이션하는 추세를 고려할 때, 이런 경험은 실무에서 큰 가치를 가질 수 있습니다. 저는 이런 업계 트렌드에 맞춘 학습을 미리 해보고 싶었습니다.

또한 SALT는 목표 저축, 게이미피케이션, 소셜 챌린지 등 다양한 기능 모듈을 가진 애플리케이션이었고, 개발을 진행하면서 서비스의 규모가 예상보다 커지고 있었습니다. 이런 상황에서 각 기능을 독립적으로 개발하고 관리할 수 있는 마이크로프론트엔드가 적합하다고 판단했습니다.

먼저 아래는 마이크로 프론트엔드 구축 과정입니다.

- [개인 프로젝트에 마이크로프론트엔드 도입하기: 새로운 아키텍처 탐구](https://velog.io/@tkrhdrhkdduf/%EA%B0%9C%EC%9D%B8-%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8%EC%97%90-%EB%A7%88%EC%9D%B4%ED%81%AC%EB%A1%9C%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C-%EB%8F%84%EC%9E%85%ED%95%98%EA%B8%B0-%EC%83%88%EB%A1%9C%EC%9A%B4-%EC%95%84%ED%82%A4%ED%85%8D%EC%B2%98-%ED%83%90%EA%B5%AC)

- [마이크로프론트엔드 정보 교환 방식 개선](https://velog.io/@tkrhdrhkdduf/%EB%A7%88%EC%9D%B4%ED%81%AC%EB%A1%9C%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C-%EC%A0%95%EB%B3%B4-%EA%B5%90%ED%99%98-%EB%B0%A9%EC%8B%9D-%EA%B0%9C%EC%84%A0)

<img src="https://github.com/kwangyoulsagong/SALT/blob/feat2/adding-goals/readmeAsset/image-2.png" alt="블록 에디터 2" />

<br />

### 성능 최적화

- [Message Event Bus 구현](https://velog.io/@tkrhdrhkdduf/Event-Message-Bus-%EA%B5%AC%ED%98%84)

MessageEventBus는 마이크로프론트엔드 환경에서 애플리케이션 간 통신을 위한 이벤트 기반 메시징 시스템입니다. 구현 과정에서 해결한 주요 문제점과 해결책은 다음과 같습니다:

#### 1. 싱글톤 패턴 구현

문제점: 여러 독립적인 마이크로프론트엔드 앱들이 동일한 MessageEventBus 인스턴스를 공유해야 했습니다.
해결책:

싱글톤 패턴을 적용하고 window 객체를 활용하여 전역적으로 접근 가능한 인스턴스를 생성했습니다.
생성자는 private으로 선언하고, getInstance() 메서드를 통해서만 접근할 수 있게 했습니다.
브라우저 환경에서는 window 객체에 인스턴스를 저장하여 모든 앱이 같은 인스턴스를 공유하도록 했습니다.

#### 2. 페이지 이동 시 데이터 유지

문제점: 사용자가 다른 페이지로 이동했을 때 선택했던 정보가 사라지는 문제가 있었습니다.
해결책:

각 이벤트 타입별로 마지막 이벤트를 lastEvents Map에 저장했습니다.
새로운 구독자가 등록될 때 해당 이벤트 타입의 마지막 이벤트가 있으면 즉시 알려주는 방식을 구현했습니다.
setTimeout을 사용하여 비동기적으로 콜백을 실행함으로써 프레임워크 렌더링 사이클과 관련된 버그를 해결했습니다.

#### 3. React 컴포넌트에서의 사용성 향상

문제점: MessageEventBus를 React 컴포넌트에서 직접 사용하기 불편했습니다.
해결책:

useMessageEventBus 훅을 만들어 React 컴포넌트에서 쉽게 사용할 수 있도록 했습니다.
publish 함수와 useSubscription 훅을 제공하여 이벤트 발행과 구독을 쉽게 할 수 있게 했습니다.

#### 4. 클로저 문제 해결

문제점: 콜백 함수가 바뀔 때마다 구독을 다시 하면 성능이 안 좋아지고, 안 하면 최신 콜백이 호출되지 않는 클로저 문제가 있었습니다.
해결책:

useRef를 사용하여 항상 최신 콜백 함수를 참조할 수 있게 했습니다.
콜백 함수는 의존성 배열에서 제거하고, messageType이 변경될 때만 구독을 새로 하도록 구현했습니다.
이를 통해 불필요한 구독/해제를 방지하면서도 항상 최신 콜백을 사용할 수 있었습니다.

이러한 접근법은 React의 렌더링 사이클과 잘 조화되면서 성능과 반응성을 모두 최적화하는 효과적인 방법이었습니다.

```
📦src
 ┣ 📂app
 ┃ ┣ 📜App.css
 ┃ ┣ 📜App.tsx
 ┃ ┗ 📜error
 ┃ ┗ 📜errorboundary
 ┃ ┗ 📜provider
 ┃ ┗ 📜routes
 ┣ 📂entities
 ┃ ┣ 📂BlockEditor
 ┃ ┣ 📂Comments
 ┃ ┃ ┗ 📂model
 ┃ ┗ 📂Notification
 ┣ 📂features
 ┃ ┣ 📂auth
 ┃ ┣ 📂Comments
 ┃ ┣ 📂favorite
 ┃ ┣ 📂MyPage
 ┃ ┣ 📂Notification
 ┃ ┣ 📂Post
 ┃ ┣ 📂Search
 ┃ ┣ 📂Setting
 ┃ ┗ 📂Write
 ┣ 📂pages
 ┃ ┣ 📂Home
 ┃ ┣ 📂Mypage
 ┃ ┣ 📂Post
 ┃ ┣ 📂Setting
 ┃ ┣ 📜SearchPage.tsx
 ┃ ┣ 📜SignUpPage.tsx
 ┃ ┣ 📜StartPage.tsx
 ┃ ┗ 📜WritePage.tsx
 ┣ 📂shared
 ┃ ┣ 📂api
 ┃ ┣ 📂BlockView
 ┃ ┣ 📂CircleImage
 ┃ ┣ 📂constants
 ┃ ┣ 📂Header
 ┃ ┣ 📂styles
 ┃ ┣ 📂Toast
 ┃ ┣ 📜Search.tsx
 ┃ ┣ 📜useApiError.ts
 ┃ ┣ 📜useInfinitePostsQuery.ts
 ┃ ┗ 📜useVirtualScroll.ts
```

<br />
